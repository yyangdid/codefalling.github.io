{"md5":"79f59d9dbe84a16e4b44f0bfd41ce8db","content":"\n<div id=\"outline-container-sec-1\" class=\"outline-2\">\n<h2 id=\"sec-1\"><span class=\"section-number-2\">1</span> 题目</h2>\n<div class=\"outline-text-2\" id=\"text-1\">\n<blockquote>\n<p>\nGiven preorder and inorder traversal of a tree, construct the binary tree.\nNote:\nYou may assume that duplicates do not exist in the tree.\n</p>\n</blockquote>\n\n<p>\n就是根据前序遍历和中序遍历来构建一个二叉树。\n</p>\n</div>\n</div>\n\n<div id=\"outline-container-sec-2\" class=\"outline-2\">\n<h2 id=\"sec-2\"><span class=\"section-number-2\">2</span> 分析</h2>\n<div class=\"outline-text-2\" id=\"text-2\">\n<p>\n这其实是个在数据结构考试中很常见的题目，看起来似乎毫无头绪，但是只要画出一颗树其实很容易分析。<sup><a id=\"fnr.1\" name=\"fnr.1\" class=\"footref\" href=\"#fn.1\">1</a></sup>]\n</p>\n\n<pre class=\"example\">\n    1\n   / \\\n  /   \\\n /     \\\n2       3\n \\     /\n  4   5\n</pre>\n\n<p>\n可以看到，它的前序遍历和中序遍历分别为 12435 和 24153，很明显前序遍历的开头一定是跟节点，而中序遍历中根节点将左右分成左右子树。我们只需用递归的思路来构建（子）树即可。\n</p>\n\n<!--more-->\n</div>\n</div>\n<div id=\"outline-container-sec-3\" class=\"outline-2\">\n<h2 id=\"sec-3\"><span class=\"section-number-2\">3</span> 代码</h2>\n<div class=\"outline-text-2\" id=\"text-3\">\n<div class=\"org-src-container\">\n\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> slicePreOrder = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">oldPreorder,inorder</span>)</span>{</span><br><span class=\"line\">  <span class=\"comment\">// example: slicePreOrder([1,2,4,3,5,6,7],[2,5,4]) ==> [2,4,5]</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> result = [];</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(inorder.length === <span class=\"number\">0</span>){</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [];</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>;i < oldPreorder.length;i++){</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(inorder.indexOf(oldPreorder[i]) > -<span class=\"number\">1</span>){</span><br><span class=\"line\">      result.push(oldPreorder[i]);</span><br><span class=\"line\">    }</span><br><span class=\"line\">  }</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> buildTree = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">preorder, inorder</span>) </span>{</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(preorder.length === <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(preorder.length == <span class=\"number\">1</span>){</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> TreeNode(preorder[<span class=\"number\">0</span>]);</span><br><span class=\"line\">  }<span class=\"keyword\">else</span>{</span><br><span class=\"line\">    <span class=\"keyword\">var</span> root = <span class=\"keyword\">new</span> TreeNode(preorder[<span class=\"number\">0</span>]);   <span class=\"comment\">// must be root</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> inorder_left = inorder.slice(<span class=\"number\">0</span>,inorder.indexOf(preorder[<span class=\"number\">0</span>]));</span><br><span class=\"line\">    <span class=\"keyword\">var</span> inorder_right = inorder.slice(inorder.indexOf(preorder[<span class=\"number\">0</span>]) + <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    root.left = buildTree(slicePreOrder(preorder,inorder_left),inorder_left);</span><br><span class=\"line\">    root.right = buildTree(slicePreOrder(preorder,inorder_right),inorder_right);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">  }</span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure>\n</div>\n\n<p>\n结果运行超时了。。\n</p>\n</div>\n</div>\n\n<div id=\"outline-container-sec-4\" class=\"outline-2\">\n<h2 id=\"sec-4\"><span class=\"section-number-2\">4</span> 改进</h2>\n<div class=\"outline-text-2\" id=\"text-4\">\n<p>\n由于 leetcode 不能 profile，只能猜测性能损失在过多次的数组复制上，改成只传递下标。\n</p>\n\n<p>\n同时，观察前序和中序遍历的结果，当我们找到根节点的时候，它在中序遍历中左边的节点是其左子树，假设此时左边节点数是 n，那么意味着前序遍历中根节点后面 n 个节点即为左子树的 n 个子节点（虽然顺序变了）。这样的话，上面的 <code>slicePreOrder</code> 也是没有必要的。右边同理。\n</p>\n\n<pre class=\"example\">\n     [preorder]\n0       12       34\n1       24       35\n |   nl  |        |\n +-------+        |\n +----------------+\n        nl+nr\n\n     [inorder]\n 01      2      34\n 24      1      53\n |  nl  | |  nr  |\n +------+ +------+\n</pre>\n\n<p>\n这种方法并不复杂，但稍有不慎可能会搞错边界条件，所以可以画张简单的图对应（例如上面的 ASCII 图，感谢 <code>artist-mode</code> ）。多次对照后终于 Accepted\n</p>\n\n<div class=\"org-src-container\">\n\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> find = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">array, start, end, item</span>)</span>{</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = start;i < end + <span class=\"number\">1</span>;i++){</span><br><span class=\"line\">\t <span class=\"keyword\">if</span>(item == array[i]){</span><br><span class=\"line\">\t     <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">\t }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> buildTreeIter = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">preorder, inorder, pstart, pend, istart, iend</span>)</span>{</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(pend < pstart || pend > preorder.length || pstart > preorder.length || iend > inorder.length || istart > inorder.length){</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    }<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(pstart == pend){</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> TreeNode(preorder[pstart]);</span><br><span class=\"line\">    }<span class=\"keyword\">else</span>{</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> root = <span class=\"keyword\">new</span> TreeNode(preorder[pstart]);   <span class=\"comment\">// must be root</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> rootIndex = find(inorder, istart, iend, preorder[pstart]);</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> leftLen = rootIndex - istart;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> rightLen = iend - rootIndex;</span><br><span class=\"line\">\troot.left = buildTreeIter(preorder, inorder, pstart + <span class=\"number\">1</span>, pstart + leftLen, istart, istart + leftLen - <span class=\"number\">1</span>);</span><br><span class=\"line\">\troot.right = buildTreeIter(preorder,</span><br><span class=\"line\">\t\t\t\t    inorder,</span><br><span class=\"line\">\t\t\t\t    pstart + leftLen + <span class=\"number\">1</span>,</span><br><span class=\"line\">\t\t\t\t    pstart + leftLen + rightLen,</span><br><span class=\"line\">\t\t\t\t    rootIndex + <span class=\"number\">1</span>, </span><br><span class=\"line\">\t\t\t\t    rootIndex + rightLen);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"><span class=\"keyword\">var</span> buildTree = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">preorder, inorder</span>) </span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(preorder.length === <span class=\"number\">0</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> [];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> buildTreeIter(preorder, inorder, <span class=\"number\">0</span>, preorder.length - <span class=\"number\">1</span>, <span class=\"number\">0</span>, inorder.length - <span class=\"number\">1</span>);</span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure>\n</div>\n</div>\n</div>\n<div id=\"footnotes\">\n<h2 class=\"footnotes\">Footnotes: </h2>\n<div id=\"text-footnotes\">\n\n<div class=\"footdef\"><sup><a id=\"fn.1\" name=\"fn.1\" class=\"footnum\" href=\"#fnr.1\">1</a></sup> <p>这张 ascii 图是使用 <a href=\"https://github.com/msbanik/drawtree\">一个名为 drawtree 的 python 库</a> 画的。</p></div>\n\n\n</div>\n</div>"}
