{"md5":"97ad2ecfe3ba571e4779f9921734384c","content":"<div id=\"outline-container-sec-1\" class=\"outline-2\">\n<h2 id=\"sec-1\"><span class=\"section-number-2\">1</span> 原题</h2>\n<div class=\"outline-text-2\" id=\"text-1\">\n<blockquote>\n<p>\nA peak element is an element that is greater than its neighbors.\n</p>\n\n<p>\nGiven an input array where num[i] ≠ num[i+1], find a peak element and return its index.\n</p>\n\n<p>\nThe array may contain multiple peaks, in that case return the index to any one of the peaks is fine.\n</p>\n\n<p>\nYou may imagine that num[-1] = num[n] = -∞.\n</p>\n\n<p>\nFor example, in array [1, 2, 3, 1], 3 is a peak element and your function should return the index number 2.\n</p>\n</blockquote>\n\n<p>\n就是找出局部最大值并返回其下标（返回任意一个就好）。\n</p>\n\n<p>\n假设最左和最右为无穷小，相邻元素都不相等。\n</p>\n</div>\n</div>\n\n<div id=\"outline-container-sec-2\" class=\"outline-2\">\n<h2 id=\"sec-2\"><span class=\"section-number-2\">2</span> 分析</h2>\n<div class=\"outline-text-2\" id=\"text-2\">\n<p>\n这道题的难度是 <code>Medium</code> ，但是看起来似乎没有什么难度，因为两端都为无穷小，所以刚开始函数一定是递增的，一旦某个点小于上一个点（递减），则这个点的前一个点必为局部最大。\n</p>\n\n<!--more-->\n</div>\n</div>\n\n<div id=\"outline-container-sec-3\" class=\"outline-2\">\n<h2 id=\"sec-3\"><span class=\"section-number-2\">3</span> 代码</h2>\n<div class=\"outline-text-2\" id=\"text-3\">\n<div class=\"org-src-container\">\n\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span><br><span class=\"line\"> * @param {number[]} nums</span><br><span class=\"line\"> * @return {number}</span><br><span class=\"line\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> findPeakElement = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">nums</span>) </span>{</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>;i<nums.length;i++){</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(nums[i] < nums[i-<span class=\"number\">1</span>]){</span><br><span class=\"line\">\t    <span class=\"keyword\">return</span> i-<span class=\"number\">1</span>;</span><br><span class=\"line\">\t}</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nums.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure>\n</div>\n\n<p>\n居然直接就 Accepted 了。。我以为至少会时间不足什么的。。\n</p>\n</div>\n</div>\n\n<div id=\"outline-container-sec-4\" class=\"outline-2\">\n<h2 id=\"sec-4\"><span class=\"section-number-2\">4</span> 改进</h2>\n<div class=\"outline-text-2\" id=\"text-4\">\n<p>\n虽然 ac 了但是不作出点改进是在对不起 Medium 的难度（十分怀疑是不是评错了）。之前给出的算法最坏情况的复杂度是 <code>O(N)</code> ，其实可以用二分法写出一个复杂度 <code>O(lgn)</code> 的，思路也很简单。\n</p>\n\n<p>\n取中间元素，如果\n</p>\n\n<ul class=\"org-ul\">\n<li>该元素大于右侧，则该元素的左侧（包括该元素）一定存在局部最大\n</li>\n<li>该元素小于右侧，则该元素右侧（不包含该元素）一定存在局部最大\n</li>\n</ul>\n\n<div class=\"org-src-container\">\n\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span><br><span class=\"line\"> * @param {number[]} nums</span><br><span class=\"line\"> * @return {number}</span><br><span class=\"line\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> findPeakElement = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">nums</span>) </span>{</span><br><span class=\"line\">    <span class=\"keyword\">var</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> right = nums.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(left < right){</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> mid = <span class=\"built_in\">Math</span>.floor((right + left)/<span class=\"number\">2</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(nums[mid] < nums[mid + <span class=\"number\">1</span>]){</span><br><span class=\"line\">\t    left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t}<span class=\"keyword\">else</span>{</span><br><span class=\"line\">\t    right = mid;</span><br><span class=\"line\">\t}</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> left;</span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure>\n</div>\n\n<p>\n再次 ac，过程中 leetcode 挂了一次-。-\n</p>\n</div>\n</div>\n"}
